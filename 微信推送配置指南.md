# 降噪平台 - 每日内容更新推送配置指南

**文档版本**: V1.0.0
**创建日期**: 2025-01-08
**适用版本**: 降噪平台 V2.0.2+
**预计配置时间**: 2-3小时

---

## 📋 目录

- [功能概述](#功能概述)
- [技术架构](#技术架构)
- [必需信息清单](#必需信息清单)
- [配置步骤](#配置步骤)
  - [步骤1: 微信服务号配置](#步骤1-微信服务号配置)
  - [步骤2: Supabase数据库配置](#步骤2-supabase数据库配置)
  - [步骤3: Next.js后端开发](#步骤3-nextjs后端开发)
  - [步骤4: 飞书自动化配置](#步骤4-飞书自动化配置)
  - [步骤5: 部署和测试](#步骤5-部署和测试)
- [测试验证](#测试验证)
- [故障排查](#故障排查)

---

## 功能概述

### 🎯 实现目标

每天早上8点，系统自动检测昨天更新的内容，通过微信服务号向所有订阅用户推送模板消息，用户点击消息可直接跳转到H5页面浏览内容。

### 📊 工作流程

```
每天早上8:00
     ↓
┌──────────────────────┐
│  飞书多维表格         │  自动触发
│  定时触发器           │  ↓
└──────────────────────┘
     ↓ HTTP POST
┌──────────────────────┐
│  Next.js API         │  1. 查询昨日新增内容
│  /api/notify/daily  │  2. 查询订阅用户列表
│                      │  3. 批量发送微信消息
└──────────────────────┘
     ↓ 调用微信API
┌──────────────────────┐
│  微信服务号           │  推送模板消息
│  模板消息             │  ↓
└──────────────────────┘
     ↓ 用户点击
┌──────────────────────┐
│  H5页面              │  查看最新内容
│  /h5                 │
└──────────────────────┘
```

### ✨ 核心功能

- ✅ 每天早上8点自动推送
- ✅ 仅推送昨天新增的内容
- ✅ 无新内容时自动跳过推送
- ✅ 批量发送给所有订阅用户
- ✅ 点击消息跳转H5页面
- ✅ 推送日志记录和统计

---

## 技术架构

### 技术栈

| 组件 | 技术 | 作用 |
|------|------|------|
| 定时触发 | 飞书多维表格自动化 | 每天8点触发HTTP请求 |
| 业务逻辑 | Next.js API路由 | 查询内容、管理用户、发送消息 |
| 消息推送 | 微信服务号模板消息 | 推送通知给订阅用户 |
| 用户管理 | Supabase PostgreSQL | 存储订阅用户和推送日志 |
| 数据源 | 飞书多维表格 | 内容数据来源 |

### 数据流转

```
飞书多维表格（内容数据）
    ↓ 定时触发
Next.js API（业务逻辑）
    ↓ 查询
Supabase（订阅用户）
    ↓ 调用
微信API（模板消息）
    ↓ 推送
用户微信（接收通知）
```

---

## 必需信息清单

### 📝 需要准备的信息

在开始配置前，请准备好以下信息。建议复制本清单到单独的文档中，逐项填写。

#### 一、微信服务号信息

```
✅ 已完成微信服务号申请和认证（需企业资质）

【基本信息】
- 服务号名称: ___________________
- 服务号AppID: wx________________
- 服务号AppSecret: ___________________
- 服务器配置Token: ___________________（自定义，如：jiangzao2024）
- EncodingAESKey: ___________________（随机生成）

【模板消息】
- 所属行业: ___________________（如：IT科技 → 互联网/电子商务）
- 模板ID: ___________________（申请后获得）
- 模板名称: 内容更新通知

【服务器地址】
- URL: https://你的域名/api/wechat/verify
- 验证状态: ⬜ 待验证 / ⬜ 已通过
```

#### 二、Supabase数据库信息

```
✅ 已有Supabase项目

【项目信息】
- 项目名称: ___________________
- 项目URL: https://_____.supabase.co
- Anon Public Key: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
- Service Role Key: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...（⚠️保密！）

【数据库配置状态】
- wechat_subscribers表: ⬜ 未创建 / ⬜ 已创建
- push_logs表: ⬜ 未创建 / ⬜ 已创建
- RLS策略: ⬜ 未配置 / ⬜ 已配置
```

#### 三、飞书配置信息

```
✅ 已有飞书多维表格和自动化权限

【飞书应用信息】
- App ID: cli_________________
- App Secret: ___________________

【多维表格信息】
- Base ID: basc________________
- Table ID: tbl________________

【Webhook密钥】（自定义，用于验证请求来源）
- Webhook Secret: ___________________（建议随机生成32位字符串）
```

#### 四、部署环境信息

```
【生产环境】
- 部署平台: ⬜ Vercel / ⬜ Railway / ⬜ 其他: ___________
- 生产域名: https://___________________
- H5页面URL: https://___________________/h5
```

#### 五、环境变量汇总

复制以下模板到 `.env.local` 文件中：

```bash
# ========== 微信服务号配置 ==========
WECHAT_APPID=                    # 从微信公众平台获取
WECHAT_APPSECRET=                # 从微信公众平台获取
WECHAT_TEMPLATE_ID=              # 模板消息ID
WECHAT_TOKEN=                    # 服务器配置Token

# ========== Supabase配置 ==========
NEXT_PUBLIC_SUPABASE_URL=        # 已有配置
NEXT_PUBLIC_SUPABASE_ANON_KEY=   # 已有配置
SUPABASE_SERVICE_ROLE_KEY=       # ⚠️新增：Service Role Key

# ========== 飞书配置 ==========
FEISHU_APP_ID=                   # 已有配置
FEISHU_APP_SECRET=               # 已有配置
FEISHU_BASE_ID=                  # 已有配置
FEISHU_TABLE_ID=                 # 已有配置
FEISHU_WEBHOOK_SECRET=           # ⚠️新增：自定义密钥

# ========== 站点配置 ==========
NEXT_PUBLIC_SITE_URL=            # 已有配置
NEXT_PUBLIC_H5_URL=              # H5页面完整URL
```

---

## 配置步骤

### 步骤1: 微信服务号配置

#### 1.1 申请微信服务号（如已有可跳过）

**前置条件**：
- ⚠️ 需要企业资质（个人无法申请）
- ⚠️ 需要完成微信认证（费用约300元/年）

**操作步骤**：

1. 访问 [微信公众平台](https://mp.weixin.qq.com)
2. 点击【立即注册】→ 选择【服务号】
3. 按提示提交企业资质材料
4. 完成注册后，进入【设置与开发 → 微信认证】提交认证资料
5. 等待审核（通常3-5个工作日）

**完成标志**：
- ✅ 公众号类型显示为"服务号"
- ✅ 认证标识显示"已认证"

---

#### 1.2 获取AppID和AppSecret

**操作步骤**：

1. 登录 [微信公众平台](https://mp.weixin.qq.com)
2. 进入【设置与开发 → 基本配置】
3. 在"开发者ID(AppID)"区域：
   - 复制 **AppID**（格式如：`wx1234567890abcdef`）
   - 点击【重置】生成新的 **AppSecret**
   - ⚠️ 立即复制保存AppSecret（只显示一次）

**填写到信息清单**：
```
WECHAT_APPID=wx1234567890abcdef
WECHAT_APPSECRET=你的AppSecret
```

---

#### 1.3 配置服务器地址（第一次配置会失败，需要先部署代码）

**操作步骤**：

1. 在【设置与开发 → 基本配置】的"服务器配置"区域
2. 点击【修改配置】
3. 填写以下信息：
   - **URL**: `https://你的域名/api/wechat/verify`
   - **Token**: 自定义（建议：`jiangzao2024`）
   - **EncodingAESKey**: 点击【随机生成】
   - **消息加解密方式**: 选择"明文模式"
4. ⚠️ 暂时不要点击【提交】（等步骤3代码部署后再提交）

**填写到信息清单**：
```
WECHAT_TOKEN=jiangzao2024
```

---

#### 1.4 申请模板消息权限

**操作步骤**：

1. 进入【功能 → 模板消息】
2. 如未开通，点击【申请开通】
3. 选择所属行业（每月只能修改1次）：
   - 主营行业：`IT科技` → `互联网/电子商务`
   - 副营行业：`IT科技` → `IT软件与服务`
4. 点击【提交】

**完成标志**：
- ✅ 显示"已开通模板消息功能"

---

#### 1.5 创建模板消息

**操作步骤**：

1. 在【功能 → 模板消息】页面
2. 点击【新增模板】
3. 搜索"内容更新通知"或"订阅成功通知"
4. 如找到合适模板，点击【选用】
5. 如未找到，点击【申请新模板】，填写：

**模板标题**: 内容更新通知

**模板内容**:
```
{{first.DATA}}
更新时间：{{keyword1.DATA}}
内容摘要：{{keyword2.DATA}}
精选数量：{{keyword3.DATA}}
{{remark.DATA}}
```

**行业**: IT科技 - 互联网/电子商务

**用途说明**: 用于向订阅用户推送每日内容更新通知

6. 提交后等待审核（通常1个工作日）
7. 审核通过后，在模板库中找到该模板，复制**模板ID**（格式如：`abc123XyZ_template_id`）

**填写到信息清单**：
```
WECHAT_TEMPLATE_ID=abc123XyZ_template_id
```

---

### 步骤2: Supabase数据库配置

#### 2.1 获取Service Role Key

**操作步骤**：

1. 登录 [Supabase Dashboard](https://supabase.com/dashboard)
2. 选择你的项目
3. 进入【Settings → API】
4. 在"Project API keys"区域找到：
   - `service_role` `secret` - 复制这个key
5. ⚠️ 注意：Service Role Key拥有完全数据库权限，请妥善保管，不要泄露！

**填写到信息清单**：
```
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

#### 2.2 创建订阅用户表

**操作步骤**：

1. 在Supabase Dashboard中，进入【SQL Editor】
2. 点击【+ New query】
3. 复制粘贴以下SQL，点击【Run】执行：

```sql
-- ========================================
-- 微信订阅用户表
-- ========================================
CREATE TABLE wechat_subscribers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  openid TEXT NOT NULL UNIQUE,           -- 微信用户openid
  nickname TEXT,                          -- 微信昵称（可选）
  subscribe_time TIMESTAMPTZ DEFAULT NOW(),  -- 订阅时间
  unsubscribe_time TIMESTAMPTZ,           -- 取消订阅时间
  is_subscribed BOOLEAN DEFAULT true,     -- 是否订阅中
  last_notify_time TIMESTAMPTZ,           -- 最后通知时间
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引（提升查询性能）
CREATE INDEX idx_wechat_subscribers_openid
  ON wechat_subscribers(openid);

CREATE INDEX idx_wechat_subscribers_subscribed
  ON wechat_subscribers(is_subscribed)
  WHERE is_subscribed = true;

-- 添加注释
COMMENT ON TABLE wechat_subscribers IS '微信服务号订阅用户表';
COMMENT ON COLUMN wechat_subscribers.openid IS '微信用户唯一标识';
COMMENT ON COLUMN wechat_subscribers.is_subscribed IS 'true=订阅中, false=已取消';
```

**验证**：
- 在【Table Editor】中，应该能看到新创建的 `wechat_subscribers` 表
- 表结构包含9个字段

---

#### 2.3 创建推送日志表

**操作步骤**：

1. 继续在【SQL Editor】中执行以下SQL：

```sql
-- ========================================
-- 推送日志表
-- ========================================
CREATE TABLE push_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  push_date DATE NOT NULL,                -- 推送日期（用于去重）
  content_ids TEXT[],                     -- 推送的内容ID列表
  total_users INT,                        -- 推送用户总数
  success_count INT DEFAULT 0,            -- 成功数量
  fail_count INT DEFAULT 0,               -- 失败数量
  push_status TEXT DEFAULT 'pending',     -- pending/success/failed/partial
  error_message TEXT,                     -- 错误信息（JSON格式）
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_push_logs_date
  ON push_logs(push_date DESC);

-- 添加注释
COMMENT ON TABLE push_logs IS '每日推送日志表';
COMMENT ON COLUMN push_logs.push_date IS '推送日期，用于防止重复推送同一天';
COMMENT ON COLUMN push_logs.push_status IS 'pending=待推送, success=全部成功, failed=全部失败, partial=部分成功';
```

**验证**：
- 在【Table Editor】中，应该能看到新创建的 `push_logs` 表
- 表结构包含9个字段

---

#### 2.4 配置RLS安全策略

**操作步骤**：

1. 继续在【SQL Editor】中执行以下SQL：

```sql
-- ========================================
-- RLS（行级安全）策略配置
-- ========================================

-- 启用RLS
ALTER TABLE wechat_subscribers ENABLE ROW LEVEL SECURITY;
ALTER TABLE push_logs ENABLE ROW LEVEL SECURITY;

-- 创建策略：仅服务端可访问
CREATE POLICY "Service role full access on wechat_subscribers"
  ON wechat_subscribers FOR ALL
  USING (auth.role() = 'service_role');

CREATE POLICY "Service role full access on push_logs"
  ON push_logs FOR ALL
  USING (auth.role() = 'service_role');
```

**说明**：
- RLS确保只有使用Service Role Key的服务端代码可以访问这两张表
- 前端代码无法直接访问，保护用户隐私

**验证**：
- 在【Authentication → Policies】中，应该能看到两条策略

---

### 步骤3: Next.js后端开发

#### 3.1 更新环境变量文件

**操作步骤**：

1. 打开项目根目录的 `.env.local` 文件
2. 在文件末尾添加以下新配置（保留原有配置）：

```bash
# ========== 微信服务号配置（新增）==========
WECHAT_APPID=wx1234567890abcdef              # 替换为你的AppID
WECHAT_APPSECRET=your_appsecret_here         # 替换为你的AppSecret
WECHAT_TEMPLATE_ID=abc123XyZ_template_id     # 替换为你的模板ID
WECHAT_TOKEN=jiangzao2024                    # 替换为你自定义的Token

# ========== Supabase Service Role Key（新增）==========
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...  # 替换为你的Service Role Key

# ========== 飞书Webhook密钥（新增）==========
FEISHU_WEBHOOK_SECRET=your_random_secret_32_chars  # 随机生成32位字符串

# ========== H5页面URL（新增）==========
NEXT_PUBLIC_H5_URL=https://aihuangshu.com/h5  # 替换为你的H5页面URL
```

3. 保存文件
4. ⚠️ 确保 `.env.local` 已在 `.gitignore` 中，不要提交到Git

**生成随机密钥**（在终端执行）：
```bash
# 生成32位随机字符串作为FEISHU_WEBHOOK_SECRET
node -e "console.log(require('crypto').randomBytes(16).toString('hex'))"
```

---

#### 3.2 创建微信API工具库

**操作步骤**：

1. 在项目根目录创建文件：`lib/wechat.ts`
2. 复制以下完整代码：

```typescript
import axios from 'axios';

const WECHAT_API_BASE = 'https://api.weixin.qq.com/cgi-bin';

// Access Token缓存（内存缓存，重启后失效）
let accessTokenCache: { token: string; expiresAt: number } | null = null;

/**
 * 获取微信Access Token（带缓存）
 * 微信access_token有效期7200秒，这里提前5分钟刷新
 */
export async function getWeChatAccessToken(): Promise<string> {
  const now = Date.now();

  // 如果缓存有效，直接返回
  if (accessTokenCache && accessTokenCache.expiresAt > now) {
    console.log('✅ 使用缓存的access_token');
    return accessTokenCache.token;
  }

  console.log('🔄 获取新的access_token...');

  // 请求新token
  const response = await axios.get(`${WECHAT_API_BASE}/token`, {
    params: {
      grant_type: 'client_credential',
      appid: process.env.WECHAT_APPID,
      secret: process.env.WECHAT_APPSECRET,
    },
  });

  if (response.data.errcode) {
    throw new Error(`获取access_token失败: ${response.data.errmsg}`);
  }

  const token = response.data.access_token;
  const expiresIn = response.data.expires_in || 7200;

  // 缓存token（提前5分钟过期）
  accessTokenCache = {
    token,
    expiresAt: now + (expiresIn - 300) * 1000,
  };

  console.log(`✅ 获取access_token成功，有效期: ${expiresIn}秒`);
  return token;
}

/**
 * 发送模板消息给单个用户
 */
export async function sendTemplateMessage(params: {
  openid: string;
  templateId: string;
  url: string; // 跳转URL
  data: {
    first: { value: string; color?: string };
    keyword1: { value: string; color?: string };
    keyword2: { value: string; color?: string };
    keyword3: { value: string; color?: string };
    remark: { value: string; color?: string };
  };
}) {
  const accessToken = await getWeChatAccessToken();

  const response = await axios.post(
    `${WECHAT_API_BASE}/message/template/send?access_token=${accessToken}`,
    {
      touser: params.openid,
      template_id: params.templateId,
      url: params.url,
      data: params.data,
    }
  );

  if (response.data.errcode !== 0) {
    throw new Error(
      `发送模板消息失败: ${response.data.errmsg} (errcode: ${response.data.errcode})`
    );
  }

  return response.data;
}

/**
 * 批量发送模板消息
 * @param users 订阅用户列表
 * @param messageData 消息数据
 * @returns 发送结果统计
 */
export async function batchSendTemplateMessage(
  users: Array<{ openid: string }>,
  messageData: {
    url: string;
    data: {
      first: { value: string };
      keyword1: { value: string };
      keyword2: { value: string };
      keyword3: { value: string };
      remark: { value: string };
    };
  }
) {
  const results = {
    total: users.length,
    success: 0,
    failed: 0,
    errors: [] as Array<{ openid: string; error: string }>,
  };

  const templateId = process.env.WECHAT_TEMPLATE_ID!;

  console.log(`📤 开始批量发送模板消息，目标用户: ${users.length}人`);

  // 批量发送（微信有频率限制，建议每秒最多10条）
  for (let i = 0; i < users.length; i++) {
    const user = users[i];
    try {
      await sendTemplateMessage({
        openid: user.openid,
        templateId,
        url: messageData.url,
        data: messageData.data,
      });
      results.success++;
      console.log(`  ✅ [${i + 1}/${users.length}] 发送成功: ${user.openid}`);

      // 延迟100ms避免频率限制（每秒最多10条）
      if (i < users.length - 1) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    } catch (error: any) {
      results.failed++;
      results.errors.push({
        openid: user.openid,
        error: error.message,
      });
      console.error(`  ❌ [${i + 1}/${users.length}] 发送失败: ${error.message}`);
    }
  }

  console.log(
    `📊 批量发送完成: 总计${results.total}人, 成功${results.success}人, 失败${results.failed}人`
  );

  return results;
}
```

3. 保存文件

**说明**：
- 该文件提供了3个核心函数：
  - `getWeChatAccessToken()`: 获取微信access_token（带缓存）
  - `sendTemplateMessage()`: 发送模板消息给单个用户
  - `batchSendTemplateMessage()`: 批量发送模板消息

---

#### 3.3 创建每日推送API路由

**操作步骤**：

1. 在项目中创建目录和文件：`app/api/notify/daily/route.ts`
2. 复制以下完整代码：

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { batchSendTemplateMessage } from '@/lib/wechat';
import { getRecords } from '@/lib/feishu';
import { transformFeishuRecord } from '@/lib/transform';

// 使用service_role key访问数据库（绕过RLS）
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

/**
 * 每日推送API
 * 由飞书自动化定时触发（每天早上8点）
 */
export async function POST(request: NextRequest) {
  const startTime = Date.now();
  console.log('\n========================================');
  console.log('📅 每日推送任务开始');
  console.log('========================================\n');

  try {
    // ============================================
    // 1. 验证请求来源（飞书webhook密钥）
    // ============================================
    const authHeader = request.headers.get('authorization');
    const expectedAuth = `Bearer ${process.env.FEISHU_WEBHOOK_SECRET}`;

    if (authHeader !== expectedAuth) {
      console.error('❌ 认证失败: 无效的Authorization header');
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    console.log('✅ 认证通过');

    // ============================================
    // 2. 获取昨天的日期范围（00:00 - 23:59）
    // ============================================
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    const yesterdayEnd = new Date(yesterday);
    yesterdayEnd.setHours(23, 59, 59, 999);

    const yesterdayDateStr = yesterday.toLocaleDateString('zh-CN');
    console.log(`📆 目标日期: ${yesterdayDateStr}`);

    // ============================================
    // 3. 检查今天是否已推送过（防止重复推送）
    // ============================================
    const todayDateStr = yesterday.toISOString().split('T')[0];
    const { data: existingLog } = await supabaseAdmin
      .from('push_logs')
      .select('id, push_status')
      .eq('push_date', todayDateStr)
      .eq('push_status', 'success')
      .single();

    if (existingLog) {
      console.log('⏭️  今天已推送过，跳过');
      return NextResponse.json({
        success: true,
        message: '今天已推送过，跳过重复推送',
      });
    }

    // ============================================
    // 4. 从飞书多维表格获取所有已发布内容
    // ============================================
    console.log('🔄 从飞书获取内容数据...');
    const rawRecords = await getRecords();
    const allContents = rawRecords
      .map(transformFeishuRecord)
      .filter((c) => c.status === 'published');
    console.log(`  ✅ 获取到 ${allContents.length} 条已发布内容`);

    // ============================================
    // 5. 筛选昨天新增的内容（根据publishedAt字段）
    // ============================================
    const yesterdayContents = allContents.filter((content) => {
      const publishDate = new Date(content.publishedAt);
      return publishDate >= yesterday && publishDate <= yesterdayEnd;
    });

    console.log(`📋 昨日新增内容: ${yesterdayContents.length}条`);

    if (yesterdayContents.length > 0) {
      yesterdayContents.forEach((content, index) => {
        console.log(`  ${index + 1}. ${content.title}`);
      });
    }

    // ============================================
    // 6. 如果没有新内容，直接返回
    // ============================================
    if (yesterdayContents.length === 0) {
      console.log('⏭️  昨日无新增内容，跳过推送');
      return NextResponse.json({
        success: true,
        message: '昨日无新增内容，跳过推送',
      });
    }

    // ============================================
    // 7. 获取所有订阅用户
    // ============================================
    console.log('🔄 查询订阅用户...');
    const { data: subscribers, error: subError } = await supabaseAdmin
      .from('wechat_subscribers')
      .select('id, openid')
      .eq('is_subscribed', true);

    if (subError) {
      throw new Error(`查询订阅用户失败: ${subError.message}`);
    }

    console.log(`👥 订阅用户数: ${subscribers?.length || 0}`);

    if (!subscribers || subscribers.length === 0) {
      console.log('⏭️  暂无订阅用户，跳过推送');
      return NextResponse.json({
        success: true,
        message: '暂无订阅用户，跳过推送',
      });
    }

    // ============================================
    // 8. 生成推送内容摘要
    // ============================================
    const contentTitles = yesterdayContents
      .slice(0, 3)
      .map((c) => `• ${c.title}`)
      .join('\n');

    const moreCount =
      yesterdayContents.length > 3
        ? `\n...及${yesterdayContents.length - 3}篇更多内容`
        : '';

    // ============================================
    // 9. 构造模板消息数据
    // ============================================
    const messageData = {
      url: process.env.NEXT_PUBLIC_H5_URL || 'https://aihuangshu.com/h5',
      data: {
        first: { value: '🎉 降噪平台有新内容更新啦！' },
        keyword1: { value: yesterdayDateStr },
        keyword2: { value: contentTitles + moreCount },
        keyword3: { value: `${yesterdayContents.length}篇` },
        remark: { value: '点击查看精彩内容 →' },
      },
    };

    console.log('\n📤 准备发送模板消息:');
    console.log(`  - 跳转URL: ${messageData.url}`);
    console.log(`  - 内容摘要:\n${contentTitles}${moreCount}`);

    // ============================================
    // 10. 批量发送模板消息
    // ============================================
    const sendResults = await batchSendTemplateMessage(subscribers, messageData);

    // ============================================
    // 11. 记录推送日志
    // ============================================
    console.log('💾 记录推送日志...');
    const { error: logError } = await supabaseAdmin.from('push_logs').insert({
      push_date: todayDateStr,
      content_ids: yesterdayContents.map((c) => c.id),
      total_users: sendResults.total,
      success_count: sendResults.success,
      fail_count: sendResults.failed,
      push_status: sendResults.failed === 0 ? 'success' : 'partial',
      error_message:
        sendResults.errors.length > 0 ? JSON.stringify(sendResults.errors) : null,
    });

    if (logError) {
      console.error('⚠️  记录推送日志失败:', logError.message);
    } else {
      console.log('  ✅ 推送日志已保存');
    }

    // ============================================
    // 12. 返回结果
    // ============================================
    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log('\n========================================');
    console.log(`✅ 每日推送任务完成 (耗时: ${duration}秒)`);
    console.log('========================================\n');

    return NextResponse.json({
      success: true,
      data: {
        contentCount: yesterdayContents.length,
        userCount: subscribers.length,
        sendResults,
        duration: `${duration}秒`,
      },
    });
  } catch (error: any) {
    console.error('\n========================================');
    console.error('❌ 每日推送任务失败');
    console.error('========================================');
    console.error(error);

    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
```

3. 保存文件

**说明**：
- 该API接收飞书自动化的POST请求
- 验证请求来源后，查询昨日新增内容
- 批量发送微信模板消息给所有订阅用户
- 记录推送日志到Supabase

---

#### 3.4 创建微信服务器验证接口

**操作步骤**：

1. 创建文件：`app/api/wechat/verify/route.ts`
2. 复制以下代码：

```typescript
import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';

/**
 * 微信服务器配置验证接口
 *
 * 微信公众平台在配置服务器地址时，会发送GET请求验证URL的有效性
 * 验证方式：
 * 1. 将token、timestamp、nonce三个参数进行字典序排序
 * 2. 拼接字符串并进行sha1加密
 * 3. 与signature对比，相同则返回echostr
 */
export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const signature = searchParams.get('signature') || '';
  const timestamp = searchParams.get('timestamp') || '';
  const nonce = searchParams.get('nonce') || '';
  const echostr = searchParams.get('echostr') || '';

  const token = process.env.WECHAT_TOKEN || '';

  console.log('🔐 微信服务器验证请求:');
  console.log(`  - signature: ${signature}`);
  console.log(`  - timestamp: ${timestamp}`);
  console.log(`  - nonce: ${nonce}`);
  console.log(`  - echostr: ${echostr}`);

  // 1. 将token、timestamp、nonce三个参数进行字典序排序
  const arr = [token, timestamp, nonce].sort();

  // 2. 拼接字符串并进行sha1加密
  const str = arr.join('');
  const sha1Hash = crypto.createHash('sha1').update(str).digest('hex');

  console.log(`  - 计算的sha1: ${sha1Hash}`);

  // 3. 与signature对比
  if (sha1Hash === signature) {
    console.log('  ✅ 验证成功');
    return new NextResponse(echostr);
  } else {
    console.error('  ❌ 验证失败');
    return new NextResponse('验证失败', { status: 403 });
  }
}

/**
 * 接收微信推送的消息和事件（可选）
 *
 * 用户关注、取消关注、发送消息等事件都会POST到这个接口
 * 可以用于自动管理订阅用户
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.text();
    console.log('📨 收到微信推送:', body);

    // TODO: 解析XML，处理关注/取消关注事件
    // 可以在这里自动添加/删除订阅用户

    // 返回"success"告知微信已收到
    return new NextResponse('success');
  } catch (error: any) {
    console.error('处理微信推送失败:', error);
    return new NextResponse('error', { status: 500 });
  }
}
```

3. 保存文件

**说明**：
- GET方法用于微信服务器验证
- POST方法用于接收微信推送的事件（可用于自动管理订阅用户，本次暂不实现）

---

#### 3.5 添加测试订阅用户（临时）

在完整的用户订阅功能开发前，我们先手动添加测试用户。

**操作步骤**：

1. 在Supabase Dashboard的【SQL Editor】中执行：

```sql
-- 插入测试订阅用户
INSERT INTO wechat_subscribers (openid, nickname, is_subscribed)
VALUES ('test_openid_12345', '测试用户', true);
```

2. 验证插入成功：在【Table Editor → wechat_subscribers】中应该能看到这条记录

**⚠️ 重要说明**：
- `openid` 是微信用户的唯一标识，真实环境需要通过微信网页授权或事件推送获取
- 测试时可以先用假的openid，但**无法收到真实消息**
- 后续需要开发用户订阅页面，让用户授权获取真实openid

---

### 步骤4: 飞书自动化配置

#### 4.1 进入飞书多维表格

**操作步骤**：

1. 打开飞书客户端或网页版
2. 进入你的多维表格（AI行业访谈精华数据）
3. 点击右上角【⚙️ 设置】→ 选择【自动化】

**完成标志**：
- ✅ 看到"自动化流程"页面

---

#### 4.2 创建自动化流程

**操作步骤**：

**第1步：创建流程**
1. 点击【+ 创建自动化】
2. 输入流程名称：`每日内容推送`
3. 点击【创建】

**第2步：设置触发条件**
1. 在"何时触发"区域，点击【选择触发条件】
2. 选择【定时触发】
3. 配置定时规则：
   - **重复频率**: 选择"每天"
   - **时间**: 选择"08:00"
   - **时区**: 选择"(UTC+08:00) 北京，重庆，香港特别行政区，乌鲁木齐"
4. 点击【确定】

**第3步：添加执行操作**
1. 在"执行什么操作"区域，点击【+ 添加操作】
2. 在操作列表中选择【发送 HTTP 请求】
3. 配置请求参数：

**请求方法**: `POST`

**请求URL**:
```
https://你的域名/api/notify/daily
```
（⚠️ 替换为你的实际生产域名）

**请求头**（点击【+ 添加请求头】）:
- 第1个请求头:
  - Key: `Content-Type`
  - Value: `application/json`
- 第2个请求头:
  - Key: `Authorization`
  - Value: `Bearer your_random_secret_32_chars`（⚠️ 替换为你在.env.local中设置的FEISHU_WEBHOOK_SECRET）

**请求体格式**: 选择 `JSON`

**请求体内容**:
```json
{
  "trigger": "feishu_automation",
  "timestamp": "{{当前时间}}"
}
```

4. 点击【确定】

**第4步：测试运行**
1. 点击页面右上角的【测试运行】
2. 查看执行结果：
   - ✅ 如果返回 `{"success":true,...}`，说明配置成功
   - ❌ 如果返回错误，检查URL、请求头、Authorization是否正确
3. 查看API日志（在终端或Vercel日志中）

**第5步：启用流程**
1. 确认测试成功后，点击右上角的【启用】开关
2. 流程状态变为"已启用"

**完成标志**：
- ✅ 流程状态显示"已启用"
- ✅ 触发条件显示"每天 08:00"
- ✅ 执行操作显示"发送 HTTP 请求"

---

#### 4.3 飞书自动化配置截图示例

**配置完成后应该看到的界面**：

```
┌─────────────────────────────────────────────┐
│ 📋 每日内容推送                    [已启用]  │
├─────────────────────────────────────────────┤
│                                             │
│ 🕐 何时触发                                 │
│ ┌─────────────────────────────────────────┐ │
│ │ 定时触发                                │ │
│ │ 每天 08:00                              │ │
│ │ (UTC+08:00) 北京                        │ │
│ └─────────────────────────────────────────┘ │
│                                             │
│ ⚡ 执行什么操作                             │
│ ┌─────────────────────────────────────────┐ │
│ │ 发送 HTTP 请求                          │ │
│ │ POST                                    │ │
│ │ https://你的域名/api/notify/daily       │ │
│ └─────────────────────────────────────────┘ │
│                                             │
│            [测试运行]  [编辑]  [删除]        │
└─────────────────────────────────────────────┘
```

---

### 步骤5: 部署和测试

#### 5.1 本地测试

**操作步骤**：

1. 启动本地开发服务器：
```bash
npm run dev
```

2. 使用curl或Postman测试API：
```bash
curl -X POST http://localhost:3000/api/notify/daily \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_random_secret_32_chars" \
  -d '{"trigger":"manual_test"}'
```

3. 查看终端日志，应该看到类似输出：
```
========================================
📅 每日推送任务开始
========================================

✅ 认证通过
📆 目标日期: 2025年1月7日
🔄 从飞书获取内容数据...
  ✅ 获取到 19 条已发布内容
📋 昨日新增内容: 2条
  1. 从谷歌"异类"到Notebook LM之母
  2. AI的"MS-DOS时代"终结者
🔄 查询订阅用户...
👥 订阅用户数: 1

📤 准备发送模板消息:
  - 跳转URL: https://你的域名/h5
  - 内容摘要:
• 从谷歌"异类"到Notebook LM之母
• AI的"MS-DOS时代"终结者

📤 开始批量发送模板消息，目标用户: 1人
  ✅ [1/1] 发送成功: test_openid_12345
📊 批量发送完成: 总计1人, 成功1人, 失败0人
💾 记录推送日志...
  ✅ 推送日志已保存

========================================
✅ 每日推送任务完成 (耗时: 1.23秒)
========================================
```

**⚠️ 注意**：
- 如果使用的是测试openid，微信不会真正发送消息
- 需要真实openid才能收到微信通知

---

#### 5.2 部署到生产环境

**操作步骤**：

**第1步：提交代码到Git**
```bash
git add .
git commit -m "feat: 添加每日内容推送功能 - 微信服务号模板消息"
git push origin main
```

**第2步：配置生产环境变量**

在Vercel/Railway的项目设置中添加环境变量：

1. 进入项目Dashboard → Settings → Environment Variables
2. 逐个添加以下变量（从`.env.local`复制）：

```
WECHAT_APPID=wx1234567890abcdef
WECHAT_APPSECRET=your_appsecret_here
WECHAT_TEMPLATE_ID=abc123XyZ_template_id
WECHAT_TOKEN=jiangzao2024
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
FEISHU_WEBHOOK_SECRET=your_random_secret_32_chars
NEXT_PUBLIC_H5_URL=https://aihuangshu.com/h5
```

3. 点击【Save】保存

**第3步：重新部署**
- Vercel会自动检测到代码变更并重新部署
- 等待部署完成（通常1-2分钟）

**完成标志**：
- ✅ 部署状态显示"Ready"
- ✅ 访问 `https://你的域名/api/wechat/verify` 不报错

---

#### 5.3 配置微信服务器地址

**前置条件**：代码已部署到生产环境

**操作步骤**：

1. 登录 [微信公众平台](https://mp.weixin.qq.com)
2. 进入【设置与开发 → 基本配置】
3. 在"服务器配置"区域，点击【修改配置】
4. 填写信息：
   - **URL**: `https://你的域名/api/wechat/verify`
   - **Token**: `jiangzao2024`（与.env.local中的WECHAT_TOKEN一致）
   - **EncodingAESKey**: 点击【随机生成】（或使用之前生成的）
   - **消息加解密方式**: 选择"明文模式"
5. 点击【提交】

**验证过程**：
- 微信会发送GET请求到你的API
- 你的API会计算sha1并返回echostr
- 如果验证成功，配置会自动保存

**完成标志**：
- ✅ 提交后没有报错
- ✅ 服务器配置状态显示"已启用"

**常见错误**：
- ❌ "URL超时": 检查域名是否正确，服务是否正常运行
- ❌ "Token验证失败": 检查WECHAT_TOKEN环境变量是否正确
- ❌ "请求失败": 查看Vercel/Railway日志排查错误

---

#### 5.4 手动触发测试推送

**操作步骤**：

1. 使用curl测试生产环境API：
```bash
curl -X POST https://你的域名/api/notify/daily \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_random_secret_32_chars" \
  -d '{"trigger":"manual_test"}'
```

2. 查看响应（应该返回类似）：
```json
{
  "success": true,
  "data": {
    "contentCount": 2,
    "userCount": 1,
    "sendResults": {
      "total": 1,
      "success": 1,
      "failed": 0,
      "errors": []
    },
    "duration": "1.23秒"
  }
}
```

3. 检查Vercel/Railway日志，确认推送流程执行成功

---

#### 5.5 验证微信消息（需要真实openid）

**⚠️ 重要提示**：
- 测试openid无法收到真实消息
- 需要获取真实用户的openid才能验证

**获取真实openid的方法**（可选，后续实现）：

1. **方法1：微信网页授权**
   - 开发一个H5订阅页面
   - 用户点击"订阅"按钮
   - 跳转到微信授权页面
   - 授权后获取用户openid
   - 保存到wechat_subscribers表

2. **方法2：用户关注事件**
   - 用户关注你的服务号时
   - 微信会POST推送到 `/api/wechat/verify`
   - 解析XML获取用户openid
   - 自动添加到wechat_subscribers表

**临时测试方案**：
1. 在微信公众平台后台【开发 → 接口权限】
2. 找到"网页授权获取用户基本信息"
3. 点击"开发者工具"
4. 使用"微信web开发者工具"扫码获取测试openid
5. 更新数据库中的测试用户openid为真实openid

---

## 测试验证

### ✅ 完整测试清单

**阶段1：环境配置验证**
- [ ] .env.local文件包含所有必需的环境变量
- [ ] Vercel/Railway生产环境变量已配置
- [ ] Supabase数据库表已创建（wechat_subscribers, push_logs）
- [ ] 微信服务号已认证，模板消息已开通

**阶段2：代码验证**
- [ ] `lib/wechat.ts` 文件已创建
- [ ] `app/api/notify/daily/route.ts` 文件已创建
- [ ] `app/api/wechat/verify/route.ts` 文件已创建
- [ ] 本地运行 `npm run dev` 无报错
- [ ] 本地运行 `npm run build` 无报错

**阶段3：接口验证**
- [ ] 访问 `http://localhost:3000/api/wechat/verify?signature=xxx` 返回验证失败（正常）
- [ ] 使用curl测试 `/api/notify/daily` 返回成功（见5.1）
- [ ] 微信服务器配置验证通过
- [ ] 生产环境API可访问

**阶段4：飞书自动化验证**
- [ ] 飞书自动化流程已创建
- [ ] 定时触发器配置为每天08:00
- [ ] HTTP请求配置正确（URL、请求头、Authorization）
- [ ] 测试运行返回成功
- [ ] 流程已启用

**阶段5：推送验证**
- [ ] 手动触发API推送成功
- [ ] Supabase push_logs表有新记录
- [ ] 用户订阅状态正确
- [ ] （如有真实openid）微信收到模板消息
- [ ] 点击消息跳转到H5页面

**阶段6：定时任务验证**
- [ ] 等待第二天早上8点
- [ ] 查看Vercel/Railway日志，确认自动触发
- [ ] 检查push_logs表，确认推送成功
- [ ] （如有真实openid）微信收到消息

---

## 故障排查

### 常见问题及解决方案

#### Q1: 微信服务器配置验证失败

**现象**：
- 提交服务器配置时，微信提示"URL超时"或"Token验证失败"

**排查步骤**：
1. 检查服务器是否已部署：访问 `https://你的域名/api/wechat/verify`
2. 检查WECHAT_TOKEN环境变量是否与填写的Token一致
3. 查看Vercel/Railway日志，是否有请求记录
4. 使用curl模拟微信请求验证：
```bash
# 生成测试签名（需要知道timestamp和nonce）
# 或者直接查看Vercel日志中微信发来的请求参数
```

**解决方案**：
- 确保域名可访问（https）
- 确保WECHAT_TOKEN环境变量正确
- 重启部署后重新提交验证

---

#### Q2: 手动测试推送返回401 Unauthorized

**现象**：
```json
{"error":"Unauthorized"}
```

**原因**：
- Authorization请求头不正确

**解决方案**：
1. 检查curl命令中的Authorization header：
```bash
-H "Authorization: Bearer your_random_secret_32_chars"
```
2. 确保`your_random_secret_32_chars`与.env.local中的FEISHU_WEBHOOK_SECRET完全一致
3. 注意Bearer后面有一个空格

---

#### Q3: 推送失败 - 获取access_token失败

**现象**：
```
❌ 获取access_token失败: invalid appid
```

**原因**：
- WECHAT_APPID或WECHAT_APPSECRET配置错误

**解决方案**：
1. 登录微信公众平台，重新检查AppID和AppSecret
2. 确保.env.local和生产环境变量都正确配置
3. 如果重置了AppSecret，需要重新部署

---

#### Q4: 推送失败 - 发送模板消息失败

**现象**：
```
❌ 发送模板消息失败: invalid template_id
```

**原因**：
- WECHAT_TEMPLATE_ID配置错误或模板未审核通过

**解决方案**：
1. 登录微信公众平台 → 功能 → 模板消息
2. 检查模板状态是否为"已通过"
3. 复制正确的模板ID（区分大小写）
4. 更新环境变量并重新部署

---

#### Q5: 飞书自动化测试失败

**现象**：
- 飞书自动化测试运行返回错误

**排查步骤**：
1. 检查请求URL是否正确（https://你的域名/api/notify/daily）
2. 检查Authorization请求头格式：`Bearer xxxxxx`（注意空格）
3. 检查Content-Type请求头是否为`application/json`
4. 查看返回的错误信息

**解决方案**：
- 根据错误信息调整配置
- 可以先用Postman测试API，确认无误后再配置飞书

---

#### Q6: 定时任务未触发

**现象**：
- 第二天早上8点，没有收到推送

**排查步骤**：
1. 检查飞书自动化流程是否已启用（开关打开）
2. 查看飞书自动化 → 执行历史，是否有执行记录
3. 查看Vercel/Railway日志，是否有API请求
4. 检查时区设置是否正确（UTC+08:00）

**解决方案**：
- 确保流程已启用
- 检查定时规则配置
- 手动测试运行验证配置正确性

---

#### Q7: 推送日志显示无新增内容

**现象**：
```
⏭️ 昨日无新增内容，跳过推送
```

**原因**：
- 飞书多维表格中，昨天确实没有新发布的内容
- 或者publishedAt字段的日期不在昨天的范围内

**解决方案**：
1. 检查飞书多维表格，确认是否有昨天发布的内容
2. 检查publishedAt字段是否正确（格式：时间戳或日期字符串）
3. 检查系统时区是否正确

---

## 📚 附录

### A. 微信模板消息示例

用户收到的消息格式：

```
┌────────────────────────────────┐
│ 降噪平台 [服务号]               │
│ ────────────────────────────── │
│                                │
│ 内容更新通知                    │
│                                │
│ 🎉 降噪平台有新内容更新啦！      │
│                                │
│ 更新时间：2025年1月7日          │
│ 内容摘要：                      │
│ • 从谷歌"异类"到Notebook LM之母 │
│ • AI的"MS-DOS时代"终结者        │
│                                │
│ 精选数量：2篇                   │
│                                │
│ 点击查看精彩内容 →              │
│                                │
└────────────────────────────────┘
```

点击后跳转到：`https://你的域名/h5`

---

### B. 环境变量速查表

| 变量名 | 示例值 | 说明 | 来源 |
|--------|--------|------|------|
| WECHAT_APPID | wx1234567890abcdef | 微信AppID | 微信公众平台 → 基本配置 |
| WECHAT_APPSECRET | xxxxxxxxxxxxx | 微信AppSecret | 微信公众平台 → 基本配置 |
| WECHAT_TEMPLATE_ID | abc123XyZ | 模板ID | 微信公众平台 → 模板消息 |
| WECHAT_TOKEN | jiangzao2024 | 服务器Token | 自定义 |
| SUPABASE_SERVICE_ROLE_KEY | eyJhbGciOiJIUzI1NiI... | 服务端密钥 | Supabase → Settings → API |
| FEISHU_WEBHOOK_SECRET | 32位随机字符串 | Webhook密钥 | 自己生成（crypto.randomBytes） |
| NEXT_PUBLIC_H5_URL | https://xxx.com/h5 | H5页面URL | 你的域名 + /h5 |

---

### C. Supabase数据库表结构

#### wechat_subscribers 表

| 字段名 | 类型 | 说明 | 默认值 |
|--------|------|------|--------|
| id | UUID | 主键 | gen_random_uuid() |
| openid | TEXT | 微信用户openid（唯一） | - |
| nickname | TEXT | 微信昵称 | NULL |
| subscribe_time | TIMESTAMPTZ | 订阅时间 | NOW() |
| unsubscribe_time | TIMESTAMPTZ | 取消订阅时间 | NULL |
| is_subscribed | BOOLEAN | 是否订阅中 | true |
| last_notify_time | TIMESTAMPTZ | 最后通知时间 | NULL |
| created_at | TIMESTAMPTZ | 创建时间 | NOW() |
| updated_at | TIMESTAMPTZ | 更新时间 | NOW() |

#### push_logs 表

| 字段名 | 类型 | 说明 | 默认值 |
|--------|------|------|--------|
| id | UUID | 主键 | gen_random_uuid() |
| push_date | DATE | 推送日期 | - |
| content_ids | TEXT[] | 内容ID数组 | - |
| total_users | INT | 推送用户总数 | - |
| success_count | INT | 成功数量 | 0 |
| fail_count | INT | 失败数量 | 0 |
| push_status | TEXT | 推送状态 | pending |
| error_message | TEXT | 错误信息 | NULL |
| created_at | TIMESTAMPTZ | 创建时间 | NOW() |

---

### D. API接口文档

#### POST /api/notify/daily

**功能**：每日推送任务

**请求头**：
```
Content-Type: application/json
Authorization: Bearer {FEISHU_WEBHOOK_SECRET}
```

**请求体**：
```json
{
  "trigger": "feishu_automation",
  "timestamp": "2025-01-08T00:00:00Z"
}
```

**响应（成功）**：
```json
{
  "success": true,
  "data": {
    "contentCount": 2,
    "userCount": 10,
    "sendResults": {
      "total": 10,
      "success": 10,
      "failed": 0,
      "errors": []
    },
    "duration": "2.34秒"
  }
}
```

**响应（无新内容）**：
```json
{
  "success": true,
  "message": "昨日无新增内容，跳过推送"
}
```

**响应（错误）**：
```json
{
  "error": "错误信息"
}
```

---

#### GET /api/wechat/verify

**功能**：微信服务器验证

**请求参数**：
```
signature: 微信加密签名
timestamp: 时间戳
nonce: 随机数
echostr: 随机字符串
```

**响应（成功）**：
```
{echostr}
```

**响应（失败）**：
```
验证失败
```

---

## 🎉 配置完成

恭喜！如果你完成了所有步骤，现在你的系统应该能够：

✅ 每天早上8点自动检测昨日新增内容
✅ 自动向所有订阅用户推送微信模板消息
✅ 用户点击消息可跳转到H5页面
✅ 推送日志完整记录在Supabase

---

## 📖 后续优化方向

1. **用户订阅管理**
   - 开发H5订阅页面（微信网页授权）
   - 自动处理用户关注/取消关注事件
   - 用户自助管理订阅状态

2. **推送内容优化**
   - 根据用户标签偏好推送个性化内容
   - 支持图文消息推送
   - A/B测试不同推送文案

3. **监控和报警**
   - 推送失败时发送飞书机器人通知
   - 统计每日推送成功率
   - 用户增长趋势分析

4. **数据分析**
   - 记录用户点击率（通过URL参数）
   - 分析最受欢迎的内容类型
   - 最佳推送时间分析

---

## 📞 需要帮助？

如果在配置过程中遇到问题：

1. 首先查看【故障排查】章节
2. 检查Vercel/Railway日志
3. 检查Supabase数据库表
4. 检查微信公众平台后台
5. 检查飞书自动化执行历史

---

**文档更新日期**: 2025-01-08
**文档版本**: V1.0.0
**维护者**: 降噪平台开发团队
